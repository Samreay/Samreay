<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>snippet on Samuel Hinton</title><link>https://cosmiccoding.com.au/tags/snippet/</link><description>Recent content in snippet on Samuel Hinton</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 08 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://cosmiccoding.com.au/tags/snippet/index.xml" rel="self" type="application/rss+xml"/><item><title>DataFrame filtering with chaining</title><link>https://cosmiccoding.com.au/tutorials/filter_chaining/</link><pubDate>Tue, 08 Nov 2022 00:00:00 +0000</pubDate><guid>https://cosmiccoding.com.au/tutorials/filter_chaining/</guid><description>If you&amp;rsquo;re like me, breaking a nice method chain to do filtering is annoying.
You might have a nice long list of operations, and then interupt it like so:
df = ( df_raw.set_index(&amp;#34;A&amp;#34;) .sort_index() .unstack() .groupby(&amp;#34;B&amp;#34;) .mean() ) df = df[df[&amp;#34;C&amp;#34;] == &amp;#34;some_value&amp;#34;] df = df.join(df2).reset_index() I&amp;rsquo;m a simple man, and I just want everything in a single chain!
Yes, in the trivial example above, you could just move the indexor into the chain, but what if you need to filter based a value in the dataframe at that instant, not in the raw dataframe?</description></item><item><title>Merging dicts with the union operator</title><link>https://cosmiccoding.com.au/tutorials/union_operators/</link><pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate><guid>https://cosmiccoding.com.au/tutorials/union_operators/</guid><description>Merging two python dictionaries is a very common question on StackOverflow. Some of the better responses have been updated for later versions of Python, but I&amp;rsquo;ve seen this crop up a few times now to write it up here.
In Python 3.9+, merging two dictionaries is now staggeringly easy.
# New in Python 3.9 x = {&amp;#34;hello&amp;#34;: &amp;#34;there&amp;#34;, &amp;#34;general&amp;#34;: &amp;#34;kenobi&amp;#34;} y = {&amp;#34;general&amp;#34;: &amp;#34;potato&amp;#34;, &amp;#34;a&amp;#34;: &amp;#34;b&amp;#34;} z = x | y # z = {&amp;#39;hello&amp;#39;: &amp;#39;there&amp;#39;, &amp;#39;general&amp;#39;: &amp;#39;potato&amp;#39;, &amp;#39;a&amp;#39;: &amp;#39;b&amp;#39;} Notice that the order of preference is right to left.</description></item><item><title>Simple Multiprocessing in Python</title><link>https://cosmiccoding.com.au/tutorials/multiprocessing/</link><pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate><guid>https://cosmiccoding.com.au/tutorials/multiprocessing/</guid><description>In this short writeup I&amp;rsquo;ll give examples of various multiprocessing libraries, how to use them with minimal setup, and what their strengths are.
If you want a TL;DR - I recommend trying out loky for single machine tasks, check out Ray for larger tasks.
# Loky, great for single machine parallelism from loky import get_reusable_executor executor = get_reusable_executor() results = list(executor.map(fn, jobs)) # Ray, great for distributing over machines import ray ray.</description></item><item><title>Trivial One Hot Encoding in Python</title><link>https://cosmiccoding.com.au/tutorials/one_hot_encoding/</link><pubDate>Thu, 25 Jun 2020 00:00:00 +0000</pubDate><guid>https://cosmiccoding.com.au/tutorials/one_hot_encoding/</guid><description>One hot encoding is something we do very commonly in machine learning, where we want to turn a categorical feature into a vector of ones and zeros that algorithms can make much easier sense of.
For example, take this toy example dataframe of people and their favourite food. At the moment, it&amp;rsquo;s useless to us.
import pandas as pd df = pd.DataFrame({ &amp;#34;Person&amp;#34;: [&amp;#34;Sam&amp;#34;, &amp;#34;Ali&amp;#34;, &amp;#34;Jane&amp;#34;, &amp;#34;John&amp;#34;], &amp;#34;FavFood&amp;#34;: [&amp;#34;Pizza&amp;#34;, &amp;#34;Vegetables&amp;#34;, &amp;#34;Cake&amp;#34;, &amp;#34;Happiness&amp;#34;] }).</description></item><item><title>Handy Python Decorators</title><link>https://cosmiccoding.com.au/tutorials/handy_python_decorators/</link><pubDate>Sat, 20 Jun 2020 00:00:00 +0000</pubDate><guid>https://cosmiccoding.com.au/tutorials/handy_python_decorators/</guid><description>Decorators are something that are criminally underused in the analysis codes I have seen in academia. So, give me a few seconds to try and espouse their virtues. First, if you are new to decorators, how they work is simple: they are a function that returns a function which has wrapped another function. Simple!
It&amp;rsquo;s easier to explain in code.
def decorator(fn): def wrapper(*args, **kwargs): print(&amp;#34;Look, I&amp;#39;ve added something here!&amp;#34;) return fn(*args, **kwargs) return wrapper @decorator def add(a, b): return a + b add(1, 2) Look, I've added something here!</description></item><item><title>One Line Python Singletons</title><link>https://cosmiccoding.com.au/tutorials/simple_singletons/</link><pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate><guid>https://cosmiccoding.com.au/tutorials/simple_singletons/</guid><description>Singletons are the idea that you want to get an instance of a class, but you only ever want there to be a single instance of that class instantiated. A nice example might be a configuration class, or a coordinator class that is used by various pieces of you code, and you want to make sure that they&amp;rsquo;re all pointing to the same instance without having to pass the object around in eery invocation!</description></item><item><title>Removing Empty Columns</title><link>https://cosmiccoding.com.au/tutorials/removing_empty_data/</link><pubDate>Tue, 16 Jun 2020 00:00:00 +0000</pubDate><guid>https://cosmiccoding.com.au/tutorials/removing_empty_data/</guid><description>The sad reality of life as a data scientist is we spend too much time cleaning and processing data. And a lot of the time, our data contains some features which simply need to go in the bin. A column of 1000 values with only 2 entries is probably not going to be useful, after all. Let&amp;rsquo;s make some data to illustrate this:
import pandas as pd import numpy as np data = np.</description></item></channel></rss>