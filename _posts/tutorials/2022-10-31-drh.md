---
layout: post
title:  "The Value of DR High Frequency"
short_title: "DR-H Value"
desc: "Investigating the secondary value from charging via DR-H."
long_desc: "Investigating the secondary value from charging via DR-H."
date: 2022-10-31
categories: [tutorial]
tags: [plotting]
loc: 'tutorials/drh/'
permalink: tutorials/drh 
redirect_from: "/drh"
---

# How much is DR High worth?

**TL;DR: £10/MW/SP = £80/MW/EFA = £470/MW/day = £173k/MW/year**

With the new DR and DM markets, we now have more ancilliary services than ever that we can choose to participate in. For older frequency services, such as FFR, the value of participating in the service comes from the availability payment that's part of each month's tender.

The power that flows in - or out of - an asset in FFR isn't really a driver of the price, as the service comes with a response payment based upon the response energy. This effectively takes any overall import/export of energy out of the equation.

*However*, this is not the case for the new services being offered. There is still the initial payment, dependent on not violating the service terms, but there's no secondary payment from either party based on the net energy resulting from fulfilling the service.

So this poses a question. How much is this response energy worth? In particular, how much is a DR high-frequency contract worth, given that entering a DR-H contract with no DR-L means that *any time the frequency is above 50Hz, we get free energy flowing into our battery?*

Let's use some historical data to answer this question!

## Loading our data

Outside of the scope of this notebook, I have exported the past year of data for the computed DR-H response (per 1MW bid in), the EFA block number, the imbalance price, and the volume-weighted mean of the M7 intraday trade prices placed in the last 10 minutes prior to gate closure (as I assume our asset is a BM here and sends its physical notication an hour prior to delivery).

<div class=" expanded-code" markdown="1">
```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sb

df = pd.read_csv("drh/data.csv.gz", parse_dates=["date_start"], index_col="date_start").bfill()
```
</div>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table class="table-auto">  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>DR-H Power</th>
      <th>M7 Price</th>
      <th>Imbalance Price</th>
      <th>EFA</th>
    </tr>
    <tr>
      <th>date_start</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2021-10-31 00:00:00+00:00</th>
      <td>-0.059054</td>
      <td>100.0</td>
      <td>170.00000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2021-10-31 00:30:00+00:00</th>
      <td>-0.066216</td>
      <td>101.0</td>
      <td>170.00000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2021-10-31 01:00:00+00:00</th>
      <td>-0.010811</td>
      <td>101.0</td>
      <td>225.00000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2021-10-31 01:30:00+00:00</th>
      <td>-0.047658</td>
      <td>120.0</td>
      <td>40.89000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2021-10-31 02:00:00+00:00</th>
      <td>-0.090631</td>
      <td>51.0</td>
      <td>26.25022</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>

To explain the backfill, not all settlement periods have active m7 trading prior to gate closure. So in this case, let's say "If there's not enough liquidity to trade on M7 now, let's assume we trade the next SP".

You can [**download the data here.**](/notebooks/drh/data.csv.gz)

## The aggregation

To look at some averages, let's group everything by EFA block, because this service is bid in by EFA block.

In addition, if we get energy in settlement period (SP) 10, we know approximately how much energy that prior to the end of the SP, and thus we can schedule an imbalance discharge for that energy in an hours time. Ie for the SP starting at 9:00am, we'd know the effective volume from DR-H at 9:29am, and can schedule a discharge at 10:30am for it. 

So instead of using the price as of right now, we use the price 90 minutes into the future.

If you have an asset out of the BM and enjoy your NIV chasing, then you wouldn't need this extra hour delay, just a single SP.

Finally, a quick note on efficiency here. Normally, I would include some baseline efficiency of around 85%, representing all the energy lost to heat and other processes that occur when you import or export energy. For example, if we import 1MW (grid side), < 1MW flows into our battery, and if we then schedule a 1MW discharge, we are both going to have ensure the asset discharges >1MW (so 1MW makes it to grid).

However, if the strategy is to be constantly exporting imbalance schedules, while importing energy from DCH, this may not be neccessary. If we are set to discharge 1MW (measured grid side), and DR-H means we should be importing 1MW, then the two net out to "Do nothing and get paid for it."

This is the best outcome. Obviously the volume is variable, so this won't always be the case, but it does mean our effective efficiency should be higher than a typical charge+discharge asset cycle. To simplify this writeup, I'm going to throw in 92.5% efficiency, and you can see the calculation for this at the end of the analysis.

<div class=" expanded-code" markdown="1">
```python
# Shift our prices
df_shift = df.copy()
df_shift[["M7 Price", "Imbalance Price"]] = df_shift[["M7 Price", "Imbalance Price"]].shift(-3)

# Making a function because I'll reuse this later
# The 0.5 comes from the power -> energy conversion (MW -> MWh)
def get_profit(df: pd.DataFrame, efficiency = 0.925) -> pd.DataFrame:
    # efficiency would be between 0 and 1. 1.0 means no energy lsot
    df["M7 Profit"] = df["M7 Price"] * -df["DR-H Power"] * efficiency * 0.5
    df["Imbalance Profit"] = df["Imbalance Price"] * -df["DR-H Power"] * efficiency * 0.5
    return df

# Aggregate please
df_profit = get_profit(df_shift)
cols = [c for c in df_profit.columns if "Profit" in c]
df_profit[cols].mean().round(2)
```
</div>

    M7 Profit           10.11
    Imbalance Profit     9.88
    dtype: float64

Simple enough, on average, each settlement period you are in DR-H, every contracted MW is worth around **£10** of profit, regardless of whether you sell on M7 or imbalance.

If we break this down by EFA:

<div class="" markdown="1">
```python
df_efa = df_profit.groupby("EFA").mean()[cols]
df_efa.round(2).add_suffix(" (£/SP/MW contracted)")
```
</div>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table class="table-auto">  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>M7 Profit (£/SP/MW contracted)</th>
      <th>Imbalance Profit (£/SP/MW contracted)</th>
    </tr>
    <tr>
      <th>EFA</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>7.47</td>
      <td>7.59</td>
    </tr>
    <tr>
      <th>2</th>
      <td>8.00</td>
      <td>7.83</td>
    </tr>
    <tr>
      <th>3</th>
      <td>10.14</td>
      <td>9.67</td>
    </tr>
    <tr>
      <th>4</th>
      <td>9.79</td>
      <td>9.88</td>
    </tr>
    <tr>
      <th>5</th>
      <td>13.85</td>
      <td>13.01</td>
    </tr>
    <tr>
      <th>6</th>
      <td>11.39</td>
      <td>11.32</td>
    </tr>
  </tbody>
</table>
</div>

Or to visualise this:

<div class=" reduced-code" markdown="1">
```python
ax = df_efa[cols].plot.barh()
```
</div>

{% include image.html url="2022-10-31-drh_10_0.png"  %}    
To restate: assuming you can sell your DR-H power instantly on imbalance or M7, you'd make around £10/MW *every settlement period* when you're in EFAs 3-6, and around £8/MW for EFAs 1 and 2.

If we wanted this to be the profit per EFA block, that's easy enough to do.

<div class="" markdown="1">
```python
(df_efa * 8).round(2).add_suffix(" (£/EFA/MW contracted)")
```
</div>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table class="table-auto">  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>M7 Profit (£/EFA/MW contracted)</th>
      <th>Imbalance Profit (£/EFA/MW contracted)</th>
    </tr>
    <tr>
      <th>EFA</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>62.32</td>
      <td>64.42</td>
    </tr>
    <tr>
      <th>2</th>
      <td>64.79</td>
      <td>65.41</td>
    </tr>
    <tr>
      <th>3</th>
      <td>81.86</td>
      <td>81.79</td>
    </tr>
    <tr>
      <th>4</th>
      <td>80.55</td>
      <td>82.60</td>
    </tr>
    <tr>
      <th>5</th>
      <td>108.86</td>
      <td>105.84</td>
    </tr>
    <tr>
      <th>6</th>
      <td>89.81</td>
      <td>89.96</td>
    </tr>
  </tbody>
</table>
</div>

Yes, ironic that I write this simple "Assume 1 EFA = 8 SP" literally the day after London changed timezones and violated that assumption for EFA 1. It's close enough.

Now, extrapolating to a year:

<div class=" expanded-code" markdown="1">
```python
(df_profit[cols].mean() * (365 * 48) / 1000).add_suffix(" (£k/Year/MW contracted)").round(2)
```
</div>

    M7 Profit (£k/Year/MW contracted)           177.05
    Imbalance Profit (£k/Year/MW contracted)    173.16
    dtype: float64

So when we scaling DR-H up to a year, it gives a profit of **£173k**.

For another unit, this means that parking your asset in DR-H nets you approximately **£470/MW/day.** 

## Extensions

#### Seasonality

We all know winter prices can get *crazy*. That might be reflected in the value of our DR-H contracts. For simplicity (and given the similarity of profits above), I'll assume we decide to sell on imbalance rather than M7. Don't worry, I reran this after picking M7 and the results don't change.

<div class="" markdown="1">
```python
month = df_profit.index.month.rename("Month")
df_month = df_shift.groupby(["EFA", month]).mean()
df_month = df_month["Imbalance Profit"].unstack()
```
</div>

<div class=" expanded-code" markdown="1">
```python
sb.heatmap(df_month, annot=True, cbar_kws=dict(label="Profit (£/MW)"), annot_kws={"size": 8});
```
</div>

{% include image.html url="main.png" class="main img-poster" %}    
That's a crazy outlier in August for EFA 6. Lots of the grid being short and higher imbalance prices.

**Important note:** Recall I pulled the last 12 months of data. That means that after October 30th, the data being used here is from *2021!* I would expect, if we were to rerun this at the end of the year, the November and December profits would look fairly different.

#### Perfect Efficiency?

Alright, I'll peel back the curtain and explain how I got my efficiency figure. If we are waiting an hour to discharge, all I have to do is look at the difference in DR-H power 90 minutes apart.

To be clear, we are comparing two scenarios. The first (the naive one), is treating DR-H charge and imbalance discharge like they happen always in separate SP, so the asset charges, changes state of charge, and then discharges, like a normal buy-sell trade. The second scenario is what actually happens - we continually schedule discharges while, *at the same time* we continually also import energy, and only the net power changes hands.

<div class=" expanded-code" markdown="1">
```python
nominal_efficiency = 0.85 # Pretty standard battery efficiency
actual_powerflow = (df["DR-H Power"] - df["DR-H Power"].shift(3)).abs()
naive_cycle_powerflow = df["DR-H Power"].abs() + df["DR-H Power"].shift(3).abs()
fractional_cycle = (actual_powerflow / naive_cycle_powerflow).mean()
effective_efficiency = 1 - (1 - nominal_efficiency) * fractional_cycle
print(f"Starting with {nominal_efficiency=:0.1%}, ")
print(f"we calculate an average {effective_efficiency=:0.1%} ")
print(f"from {fractional_cycle=:0.3f}")
```
</div>

    Starting with nominal_efficiency=85.0%, 
    we calculate an average effective_efficiency=92.5% 
    from fractional_cycle=0.501
    
I was actually hoping for something above 95%, but hey, effectively increasing your energy efficiency in *any* way is fantastic.

#### Auxiliary Load

Batteries need power to run. Keeping things cool is always a big drain on energy. Assuming that the energy to run a battery scales with its power capacity, and using the Bloxwich asset as a baseline, we come up with appoximately **0.0065MW/MW** in auxiliary load. So for every MW power capacity, you will use about 6.5kW cooling and operating. 

We can modify the prior numbers to take this loss into account (because it is *not* included in the efficiency calculations above).

<div class=" reduced-code" markdown="1">
```python
df_aux = df_shift.copy()
df_aux["DR-H Power"] += 0.0065
df_aux = get_profit(df_aux)
df_aux.groupby("EFA")[cols].mean().round(2)
```
</div>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table class="table-auto">  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>M7 Profit</th>
      <th>Imbalance Profit</th>
    </tr>
    <tr>
      <th>EFA</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>6.98</td>
      <td>7.08</td>
    </tr>
    <tr>
      <th>2</th>
      <td>7.43</td>
      <td>7.25</td>
    </tr>
    <tr>
      <th>3</th>
      <td>9.51</td>
      <td>9.05</td>
    </tr>
    <tr>
      <th>4</th>
      <td>9.21</td>
      <td>9.29</td>
    </tr>
    <tr>
      <th>5</th>
      <td>13.09</td>
      <td>12.28</td>
    </tr>
    <tr>
      <th>6</th>
      <td>10.80</td>
      <td>10.73</td>
    </tr>
  </tbody>
</table>
</div>

And taking the global average:

<div class=" reduced-code" markdown="1">
```python
df_aux[cols].mean().round(2)
```
</div>

    M7 Profit           9.51
    Imbalance Profit    9.28
    dtype: float64

So the auxiliary load has a bit of an impact, but not much for a typical battery. We're still looking at approximately **£10/MW/SP**.

# Summary

The profit from selling DC-H energy is volatile. It changes over EFA, and month to month. However, in the vast majority of cases, it sits *above* **£7/MW/SP**. EFA 5 represents the greatest value. Freely discharging into the most profitable SP of the day is - shockingly - an effective way to make money. It is *also* a highly efficiency way to make money and reduce your asset cycling, as it reduces cycling by around 50%.

You can expect to make, on average, **£10/MW/SP** (equivalently **80/MW/EFA**, **£470/MW/day**, **£173k/MW/year**), if you just set and forget your asset into DR-H.

{% include badge.html %}

Here's the full code for convenience:

<div class="expanded-code" markdown="1">```python
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sb


df = pd.read_csv("drh/data.csv.gz", parse_dates=["date_start"], index_col="date_start").bfill()

# Shift our prices
df_shift = df.copy()
df_shift[["M7 Price", "Imbalance Price"]] = df_shift[["M7 Price", "Imbalance Price"]].shift(-3)

# Making a function because I'll reuse this later
# The 0.5 comes from the power -> energy conversion (MW -> MWh)
def get_profit(df: pd.DataFrame, efficiency = 0.925) -> pd.DataFrame:
    # efficiency would be between 0 and 1. 1.0 means no energy lsot
    df["M7 Profit"] = df["M7 Price"] * -df["DR-H Power"] * efficiency * 0.5
    df["Imbalance Profit"] = df["Imbalance Price"] * -df["DR-H Power"] * efficiency * 0.5
    return df

# Aggregate please
df_profit = get_profit(df_shift)
cols = [c for c in df_profit.columns if "Profit" in c]
df_profit[cols].mean().round(2)

df_efa = df_profit.groupby("EFA").mean()[cols]
df_efa.round(2).add_suffix(" (£/SP/MW contracted)")

ax = df_efa[cols].plot.barh()

(df_efa * 8).round(2).add_suffix(" (£/EFA/MW contracted)")

(df_profit[cols].mean() * (365 * 48) / 1000).add_suffix(" (£k/Year/MW contracted)").round(2)

month = df_profit.index.month.rename("Month")
df_month = df_shift.groupby(["EFA", month]).mean()
df_month = df_month["Imbalance Profit"].unstack()

sb.heatmap(df_month, annot=True, cbar_kws=dict(label="Profit (£/MW)"), annot_kws={"size": 8});

nominal_efficiency = 0.85 # Pretty standard battery efficiency
actual_powerflow = (df["DR-H Power"] - df["DR-H Power"].shift(3)).abs()
naive_cycle_powerflow = df["DR-H Power"].abs() + df["DR-H Power"].shift(3).abs()
fractional_cycle = (actual_powerflow / naive_cycle_powerflow).mean()
effective_efficiency = 1 - (1 - nominal_efficiency) * fractional_cycle
print(f"Starting with {nominal_efficiency=:0.1%}, ")
print(f"we calculate an average {effective_efficiency=:0.1%} ")
print(f"from {fractional_cycle=:0.3f}")

df_aux = df_shift.copy()
df_aux["DR-H Power"] += 0.0065
df_aux = get_profit(df_aux)
df_aux.groupby("EFA")[cols].mean().round(2)

df_aux[cols].mean().round(2)

```
</div>