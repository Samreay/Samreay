---
layout: post
title:  "The Value of DR High Frequency"
short_title: "DR-H Value"
desc: "Investigating the secondary value from charging via DR-H."
long_desc: "Investigating the secondary value from charging via DR-H."
date: 2022-10-31
categories: [tutorial]
tags: [plotting]
loc: 'tutorials/drh/'
permalink: tutorials/drh 
redirect_from: "/drh"
---

# How much is DR High worth?

**TL;DR: £10/MW/SP = £20/MW/hr = £80/MW/EFA = £470/MW/day = £173k/MW/year**

With the new DR and DM markets, we now have more ancillary services than ever that we can choose to participate in. For older frequency services, such as FFR, the value of participating in the service comes from the availability payment that's part of each month's tender. FFR also has a response energy payment, to help cover the cost of buying energy to fulfill the service.

However... what if we don't enter on both the high and low side (where we charge and discharge power respectively)?

This poses a question. How much is this response energy worth? In particular, how much is a DR high-frequency contract worth, given that entering a DR-H contract with no DR-L means that *any time the frequency is above 50Hz, we get free energy flowing into our battery?*

Let's use some historical data to answer this question!

## Loading our data

Outside of the scope of this notebook, I have exported the past year of data for the computed DR-H response (per 1MW bid in), the EFA block number, the imbalance price, and the volume-weighted mean of the M7 intraday trade prices placed in the last 10 minutes prior to gate closure (as I assume our asset is a BM here and sends its physical notication an hour prior to delivery).

<div class=" expanded-code" markdown="1">
```python
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sb

df = pd.read_csv("data.csv.gz", parse_dates=["date_start"], index_col="date_start").bfill()
```
</div>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table class="table-auto">  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>DR-H Power</th>
      <th>M7 Price</th>
      <th>Imbalance Price</th>
      <th>EFA</th>
    </tr>
    <tr>
      <th>date_start</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2021-10-31 00:00:00+00:00</th>
      <td>-0.059054</td>
      <td>100.0</td>
      <td>170.00000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2021-10-31 00:30:00+00:00</th>
      <td>-0.066216</td>
      <td>101.0</td>
      <td>170.00000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2021-10-31 01:00:00+00:00</th>
      <td>-0.010811</td>
      <td>101.0</td>
      <td>225.00000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2021-10-31 01:30:00+00:00</th>
      <td>-0.047658</td>
      <td>120.0</td>
      <td>40.89000</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2021-10-31 02:00:00+00:00</th>
      <td>-0.090631</td>
      <td>51.0</td>
      <td>26.25022</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>

To explain the backfill, not all settlement periods have active m7 trading prior to gate closure. So in this case, let's say "If there's not enough liquidity to trade on M7 now, let's assume we trade the next SP".

You can [**download the data here.**](/notebooks/drh/data.csv.gz)

## The aggregation

To look at some averages, let's group everything by EFA block, because this service is bid in by EFA block.

In addition, if we get energy in settlement period (SP) 10, we know approximately how much energy that we've received prior to the end of the SP, and thus we can schedule an imbalance discharge for that energy in an hours time. Ie for the SP starting at 9:00am, we'd know the effective volume from DR-H at 9:29am, and can schedule a discharge at 10:30am for it. 

So instead of using the price as of right now, we use the price 90 minutes into the future.

If you have an asset out of the BM and enjoy your NIV chasing (and thus don't have to worry about the hour delay of submitting your physical notifications), then you wouldn't need this extra hour delay, just a single SP.

Finally, a quick note on efficiency here. Normally, we would include some baseline efficiency of around 85%, representing all the energy lost to heat and other processes that occur when you import or export energy. For example, if we import 1MW (grid side), < 1MW flows into our battery, and if we then schedule a 1MW discharge, we are going to have ensure that the asset discharges >1MW, so 1MW makes it to the grid).

However, if the strategy is to be constantly exporting imbalance schedules, while importing energy from DCH, this may not be necessary. If we are set to discharge 1MW (measured grid side), and DR-H means we should be importing 1MW, then the two net out to "Do nothing and get paid for it."

This is the best outcome. Obviously the volume is variable, so this won't always be the case, but it does mean our effective efficiency should be higher than a typical charge+discharge asset cycle. To simplify this writeup, I'm going to throw in 92.5% efficiency, and you can see the calculation for this at the end of the analysis.

<div class=" expanded-code" markdown="1">
```python
# Shift our prices
df_shift = df.copy()
df_shift[["M7 Price", "Imbalance Price"]] = df_shift[["M7 Price", "Imbalance Price"]].shift(-3)

# Making a function because I'll reuse this later
# The 0.5 comes from the power -> energy conversion (MW -> MWh)
def get_profit(df: pd.DataFrame, efficiency = 0.925) -> pd.DataFrame:
    # efficiency would be between 0 and 1. 1.0 means no energy lost
    df["M7 Profit"] = df["M7 Price"] * -df["DR-H Power"] * efficiency * 0.5
    df["Imbalance Profit"] = df["Imbalance Price"] * -df["DR-H Power"] * efficiency * 0.5
    return df

# Aggregate please
df_profit = get_profit(df_shift)
cols = [c for c in df_profit.columns if "Profit" in c]
df_profit[cols].mean().round(2)
```
</div>

    M7 Profit           10.11
    Imbalance Profit     9.88
    dtype: float64

Simple enough, on average, each settlement period you are in DR-H, every contracted MW is worth around **£10** of profit, regardless of whether you sell on M7 or imbalance.

If we break this down by EFA, and double it to convert into hourly profit instead of SP profit:

<div class="" markdown="1">
```python
df_efa = df_profit.groupby("EFA").mean()[cols]
df_efa.round(2).add_suffix(" (£/hr/MW contracted)") * 2
```
</div>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table class="table-auto">  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>M7 Profit (£/hr/MW contracted)</th>
      <th>Imbalance Profit (£/hr/MW contracted)</th>
    </tr>
    <tr>
      <th>EFA</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>14.94</td>
      <td>15.18</td>
    </tr>
    <tr>
      <th>2</th>
      <td>16.00</td>
      <td>15.66</td>
    </tr>
    <tr>
      <th>3</th>
      <td>20.28</td>
      <td>19.34</td>
    </tr>
    <tr>
      <th>4</th>
      <td>19.58</td>
      <td>19.76</td>
    </tr>
    <tr>
      <th>5</th>
      <td>27.70</td>
      <td>26.02</td>
    </tr>
    <tr>
      <th>6</th>
      <td>22.78</td>
      <td>22.64</td>
    </tr>
  </tbody>
</table>
</div>

Or to visualise this:

<div class=" reduced-code" markdown="1">
```python
ax = (df_efa[cols] * 2).plot.barh()
```
</div>

{% include image.html url="2022-10-31-drh_10_0.png"  %}    
To restate: assuming you can sell your DR-H power instantly on imbalance or M7, you'd make around £20/MW *every hour* when you're in EFAs 3-6, and around £8/hr/MW for EFAs 1 and 2.

If we wanted this to be the profit per EFA block, that's easy enough to do.

<div class="" markdown="1">
```python
(df_efa * 8).round(2).add_suffix(" (£/EFA/MW contracted)")
```
</div>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table class="table-auto">  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>M7 Profit (£/EFA/MW contracted)</th>
      <th>Imbalance Profit (£/EFA/MW contracted)</th>
    </tr>
    <tr>
      <th>EFA</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>62.32</td>
      <td>64.42</td>
    </tr>
    <tr>
      <th>2</th>
      <td>64.79</td>
      <td>65.41</td>
    </tr>
    <tr>
      <th>3</th>
      <td>81.86</td>
      <td>81.79</td>
    </tr>
    <tr>
      <th>4</th>
      <td>80.55</td>
      <td>82.60</td>
    </tr>
    <tr>
      <th>5</th>
      <td>108.86</td>
      <td>105.84</td>
    </tr>
    <tr>
      <th>6</th>
      <td>89.81</td>
      <td>89.96</td>
    </tr>
  </tbody>
</table>
</div>

Yes, ironic that we write this simple "Assume 1 EFA = 8 SP" literally the day after London changed timezones and violated that assumption for EFA 1. Given we've got a whole year of data though, it balances out.

Now, extrapolating to a year:

<div class=" expanded-code" markdown="1">
```python
(df_profit[cols].mean() * (365 * 48) / 1000).add_suffix(" (£k/Year/MW contracted)").round(2)
```
</div>

    M7 Profit (£k/Year/MW contracted)           177.05
    Imbalance Profit (£k/Year/MW contracted)    173.16
    dtype: float64

So when we scale DR-H up to a year, it gives a profit of **£173k**.

For another unit, this means that parking your asset in DR-H nets you approximately **£470/MW/day.** 

## Extensions

#### Seasonality

We all know winter prices can get *crazy*. That might be reflected in the value of our DR-H contracts. For simplicity (and given the similarity of profits above), I'll assume we decide to sell on imbalance rather than M7. Don't worry, I reran this after picking M7 and the results don't change.

<div class="" markdown="1">
```python
month = df_profit.index.month.rename("Month")
df_month = df_shift.groupby(["EFA", month]).mean()
df_month = df_month["Imbalance Profit"].unstack()
```
</div>

<div class=" expanded-code" markdown="1">
```python
# Again note the doubling to get us into hourly profit instead of SP profit.
sb.heatmap(df_month * 2, annot=True, cbar_kws=dict(label="Profit (£/hr/MW)"), annot_kws={"size": 8});
```
</div>

{% include image.html url="main.png" class="main img-poster" %}    
That's a crazy outlier in August for EFA 6. Lots of the grid being short and higher imbalance prices.

**Important note:** Recall we pulled the last 12 months of data. That means that after October 30th, the data being used here is from *2021!* we would expect, if we were to rerun this at the end of the year, the November and December profits may look fairly different.

#### Perfect Efficiency?

Alright, let's peel back the curtain and explain how we got my efficiency figure. If we are waiting 90 minutes to discharge, all we have to do is look at the difference in DR-H power 90 minutes apart.

To be clear, we are comparing two scenarios. The first (the naive one), is treating DR-H charge and imbalance discharge like they happen always in separate SP, so the asset charges, changes state of charge, and then discharges, like a normal buy-sell trade. This is not what happens. We happens is that we continually schedule discharges while, *at the same time*, we continually also import energy, and only the net power changes hands.

So what we want to do is look at the difference in DR-H power 90 minutes apart, because it's only that difference which our asset has to make up.

<div class=" expanded-code" markdown="1">
```python
nominal_efficiency = 0.85 # Pretty standard battery efficiency
actual_powerflow = (df["DR-H Power"] - df["DR-H Power"].shift(3)).abs()
naive_cycle_powerflow = df["DR-H Power"].abs() + df["DR-H Power"].shift(3).abs()
fractional_cycle = (actual_powerflow / naive_cycle_powerflow).mean()
effective_efficiency = 1 - (1 - nominal_efficiency) * fractional_cycle
print(f"Starting with {nominal_efficiency=:0.1%}, ")
print(f"we calculate an average {effective_efficiency=:0.1%} ")
print(f"from {fractional_cycle=:0.3f}")
```
</div>

    Starting with nominal_efficiency=85.0%, 
    we calculate an average effective_efficiency=92.5% 
    from fractional_cycle=0.501
    
It would be nice to break 95%, but hey, effectively increasing your energy efficiency in *any* way is fantastic.

#### Auxiliary Load

Batteries need power to run. Keeping things cool is always a big drain on energy. Assuming that the energy to run a battery scales with its power capacity, and using the Bloxwich asset as a baseline, we come up with approximately **0.0065MW/MW** in auxiliary load. So for every MW power capacity, you will use about 6.5kW cooling and operating. This is with a one hour duration asset, and I would expect that if you have assets of longer or shorter durations, this number might change.

We can modify the prior numbers to take this loss into account (because it is *not* included in the efficiency calculations above).

<div class=" reduced-code" markdown="1">
```python
df_aux = df_shift.copy()
df_aux["DR-H Power"] += 0.0065
df_aux = get_profit(df_aux)
df_aux.groupby("EFA")[cols].mean().round(2) * 2
```
</div>

<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table class="table-auto">  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>M7 Profit</th>
      <th>Imbalance Profit</th>
    </tr>
    <tr>
      <th>EFA</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>13.96</td>
      <td>14.16</td>
    </tr>
    <tr>
      <th>2</th>
      <td>14.86</td>
      <td>14.50</td>
    </tr>
    <tr>
      <th>3</th>
      <td>19.02</td>
      <td>18.10</td>
    </tr>
    <tr>
      <th>4</th>
      <td>18.42</td>
      <td>18.58</td>
    </tr>
    <tr>
      <th>5</th>
      <td>26.18</td>
      <td>24.56</td>
    </tr>
    <tr>
      <th>6</th>
      <td>21.60</td>
      <td>21.46</td>
    </tr>
  </tbody>
</table>
</div>

And taking the global average:

<div class=" reduced-code" markdown="1">
```python
df_aux[cols].mean().round(2) * 2
```
</div>

    M7 Profit           19.02
    Imbalance Profit    18.56
    dtype: float64

So the auxiliary load has a bit of an impact, but not much for a typical battery. We're still looking at approximately **£20/hr/MW contracted**.

# Summary

The profit from selling DC-H energy is volatile. It changes over EFA, and month to month. However, in the vast majority of cases, it sits *above* **£7/MW/SP**. EFA 5 represents the greatest value. Freely discharging into the most profitable SP of the day is - shockingly - an effective way to make money. It is *also* a highly efficient way to make money and reduce your asset cycling, as it reduces cycling by around 50%.

You can expect to make, on average, **£10/MW/SP** (equivalently  **80/MW/hr**, **80/MW/EFA**, **£470/MW/day**, **£173k/MW/year**), if you just set and forget your asset into DR-H.

{% include badge.html %}

Here's the full code for convenience:

<div class="expanded-code" markdown="1">```python
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sb


df = pd.read_csv("data.csv.gz", parse_dates=["date_start"], index_col="date_start").bfill()

# Shift our prices
df_shift = df.copy()
df_shift[["M7 Price", "Imbalance Price"]] = df_shift[["M7 Price", "Imbalance Price"]].shift(-3)

# Making a function because I'll reuse this later
# The 0.5 comes from the power -> energy conversion (MW -> MWh)
def get_profit(df: pd.DataFrame, efficiency = 0.925) -> pd.DataFrame:
    # efficiency would be between 0 and 1. 1.0 means no energy lost
    df["M7 Profit"] = df["M7 Price"] * -df["DR-H Power"] * efficiency * 0.5
    df["Imbalance Profit"] = df["Imbalance Price"] * -df["DR-H Power"] * efficiency * 0.5
    return df

# Aggregate please
df_profit = get_profit(df_shift)
cols = [c for c in df_profit.columns if "Profit" in c]
df_profit[cols].mean().round(2)

df_efa = df_profit.groupby("EFA").mean()[cols]
df_efa.round(2).add_suffix(" (£/hr/MW contracted)") * 2

ax = (df_efa[cols] * 2).plot.barh()

(df_efa * 8).round(2).add_suffix(" (£/EFA/MW contracted)")

(df_profit[cols].mean() * (365 * 48) / 1000).add_suffix(" (£k/Year/MW contracted)").round(2)

month = df_profit.index.month.rename("Month")
df_month = df_shift.groupby(["EFA", month]).mean()
df_month = df_month["Imbalance Profit"].unstack()

# Again note the doubling to get us into hourly profit instead of SP profit.
sb.heatmap(df_month * 2, annot=True, cbar_kws=dict(label="Profit (£/hr/MW)"), annot_kws={"size": 8});

nominal_efficiency = 0.85 # Pretty standard battery efficiency
actual_powerflow = (df["DR-H Power"] - df["DR-H Power"].shift(3)).abs()
naive_cycle_powerflow = df["DR-H Power"].abs() + df["DR-H Power"].shift(3).abs()
fractional_cycle = (actual_powerflow / naive_cycle_powerflow).mean()
effective_efficiency = 1 - (1 - nominal_efficiency) * fractional_cycle
print(f"Starting with {nominal_efficiency=:0.1%}, ")
print(f"we calculate an average {effective_efficiency=:0.1%} ")
print(f"from {fractional_cycle=:0.3f}")

df_aux = df_shift.copy()
df_aux["DR-H Power"] += 0.0065
df_aux = get_profit(df_aux)
df_aux.groupby("EFA")[cols].mean().round(2) * 2

df_aux[cols].mean().round(2) * 2

```
</div>